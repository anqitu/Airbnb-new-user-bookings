# -*- coding: utf-8 -*-
"""exploratory-data-analysis

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1H2Sqw8MZEKdWdEipcB-y1NcqU9J3WbeC

## Ideas
- Trend of any aspect of ratio
- Map of each destinations
- Columns for NDF

## Questions
- Do we need to do Exploratory Data Analysis via plotting apart from modelling?
- Do we need to take care of the test data? Or just ignore it?
- Some columns are not distributed evenly for train and test. Does it matter?

## 1. Environment Setup

#### Set Working Directory
"""

import os
os.getcwd()

WORKING_DIR = '/Users/anqitu/Workspaces/NTU/Airbnb-new-user-bookings'
os.listdir(WORKING_DIR)

"""#### Import libraries"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# Draw inline
# %matplotlib inline

# Set figure aesthetics
plt.style.use('fivethirtyeight')
plt.rcParams["figure.figsize"] = [12,8]

# Ignore warnings
import warnings
warnings.filterwarnings('ignore')

# Pandas settings
pd.set_option('display.max_columns', 500)
pd.options.display.float_format = '{:,.5f}'.format

"""#### Constants"""

SEED = 2019
TRAIN_PATH = os.path.join(WORKING_DIR, 'raw_data/train_users.csv')
TEST_PATH = os.path.join(WORKING_DIR, 'raw_data/test_users.csv')
SESSIONS_PATH = os.path.join(WORKING_DIR, 'raw_data/sessions.csv')
AGE_GENDER_PATH = os.path.join(WORKING_DIR, 'raw_data/age_gender_bkts.csv')
COUNTRIES_PATH = os.path.join(WORKING_DIR, 'raw_data/countries.csv')
SAMPLE_SUBMISSION_PATH = os.path.join(WORKING_DIR, 'raw_data/sample_submission_NDF.csv')

categorical_features = [
    'affiliate_channel',
    'affiliate_provider',
    'first_affiliate_tracked', # A user can search before they sign up.
    'first_browser',
    'first_device_type',
    'gender',
    'language',
    'signup_app',
    'signup_method',
    'signup_flow' # a key to particular pages - an index for an enumerated list.
]

"""#### Loading data"""

# train_users = pd.read_csv(TRAIN_PATH)
train_users = pd.read_csv(TRAIN_PATH, nrows=20000)
test_users = pd.read_csv(TEST_PATH)
# sessions = pd.read_csv(SESSIONS_PATH)
# age_gender_bkts = pd.read_csv(AGE_GENDER_PATH)
# countries = pd.read_csv(COUNTRIES_PATH)
# sample_submission_NDF = pd.read_csv(SAMPLE_SUBMISSION_PATH)

"""## 2. Analyze Data

#### Useful functions
"""

def display_null_percentage(data):
    df = data.isnull().sum().reset_index().rename(columns = {0: 'Count', 'index': 'Column'})
    df['Frequency'] = df['Count'] / data.shape[0] * 100
    pd.options.display.float_format = '{:.2f}%'.format
    print(df)
    pd.options.display.float_format = None

def display_category_counts(data, categorical_features):
  for categorical_feature in categorical_features:
    print('-' * 30)
    print(categorical_feature)
    print(data[categorical_feature].value_counts(dropna=False))

"""#### Overview"""

# train_users.shape
# train_users.info()
# train_users.head()
# train_users.describe()
# train_users.nunique()
# display_null_percentage(train_users)
# display_category_counts(data = train_users, categorical_features = categorical_features)

# test_users.shape
# test_users.info()
# test_users.head()
# test_users.describe()
# test_users.nunique()
# display_null_percentage(test_users)
# display_category_counts(data = test_users, categorical_features = categorical_features)

# sessions.shape
# sessions.info()
# sessions.head()
# sessions.describe()
# sessions.nunique()
# display_null_percentage(sessions)
#
# set(train_users['id']).intersection(set(test_users['id']))
# len(set(train_users['id']).intersection(set(sessions['user_id'])))
# len(set(train_users['id']).difference(set(sessions['user_id'])))
# len(set(test_users['id']).intersection(set(sessions['user_id'])))
# len(set(test_users['id']).difference(set(sessions['user_id'])))
#
# age_gender_bkts.shape
# age_gender_bkts.head()
# age_gender_bkts.describe()
# age_gender_bkts.nunique()
# display_null_percentage(age_gender_bkts)
#
# countries.shape
# countries.head()
# countries.describe()
# countries.nunique()
# display_null_percentage(countries)

"""#### Age

For the ages above 150, the users have inserted their year of birth instead of age. We can fix this by subtracting the given year from the current year (for this dataset it was 2015) to get the age of the user. For ages less than 15, they can be considered as incorrect inputs and can be filtered out.

> Indented block
"""

# train_users[~pd.isna(train_users['age'])].sort_values(['age'])
# train_users[train_users['age'] > 100].sort_values(['age'])
# train_users[train_users['age'] > 100]['age'].hist()
# train_users[train_users['age'] > 1500].sort_values(['age'])
# train_users[train_users['age'] > 1500]['age'].describe()
# train_users[train_users['age'] < 20]['age'].hist()
# train_users[train_users['age'] < 15].sort_values(['age'])
# train_users[(train_users['age'] > 15) & (train_users['age'] < 100)]['age'].hist()
# train_users[(train_users['age'] > 15) & (train_users['age'] < 100)]['age'].describe()
# train_users[(train_users['age'] > 15) & (train_users['age'] < 100)].shape
# train_users[~pd.isna(train_users['age'])].shape

# test_users[~pd.isna(test_users['age'])].sort_values(['age'])
# test_users[test_users['age'] > 100].sort_values(['age'])
# test_users[test_users['age'] > 100]['age'].hist()
# test_users[test_users['age'] > 1500].sort_values(['age'])
# test_users[test_users['age'] > 1500]['age'].describe()
# test_users[test_users['age'] < 20]['age'].hist()
# test_users[test_users['age'] < 15].sort_values(['age'])
# test_users[(test_users['age'] > 15) & (test_users['age'] < 100)]['age'].hist()
# test_users[(test_users['age'] > 15) & (test_users['age'] < 100)]['age'].describe()
# test_users[(test_users['age'] > 15) & (test_users['age'] < 100)].shape
# test_users[~pd.isna(test_users['age'])].shape

"""#### Findings
1. test_user data has all 'date_first_booking' missing --> Because not sure whether has booked
   train_user data has 44% 'date_first_booking' missing --> Because no booking yet
2. Both train and test data has almost half 'age' missing --> TODO: Engineer 'age_missing' column
3. There are outliers for 'age' column (1-5 / >100 / 2014) --> TODO: Identify outliers
7. Most date columns are not date objects --> TODO: Convert to datetime object
4. There is '-unknown-' values for 'gender', 'language', 'first_browser' column --> TODO: Convert '-unknown-' to na
5. Both train and test has less than 3% 'first_affiliate_tracked' missing --> TODO: Drop those rows or replace with 'untracked'
6. Web sessions log for users are not complete for both train data and test data

## Prepare Data (Clean + Engineer)
"""

train_users['data'] = 'train'
test_users['data'] = 'test'

users = pd.concat([train_users, test_users])

# Convert '-unknown-' to 'NA'
users['gender'].replace('-unknown-', 'NA', inplace=True)
users['language'].replace('-unknown-', 'NA', inplace=True)
users['first_browser'].replace('-unknown-', 'NA', inplace=True)
# display_category_counts(data = users, categorical_features = categorical_features)

# Convert na for  'first_affiliate_tracked' as 'untracked' which is the most common one.
users['first_affiliate_tracked'].replace(np.nan, 'untracked', inplace=True)

# Correct those ages entered as year
users.loc[users['age']>1500,'age'] = 2015 - users.loc[users['age']>1500,'age']
# users.age.describe()

# Set 'age' outliers as NA
users.loc[users['age'] > 95, 'age'] = np.nan
users.loc[users['age'] < 15, 'age'] = np.nan
# users.age.describe()

# Convert to datetime object
users['date_account_created'] = pd.to_datetime(users['date_account_created'])
users['date_first_active'] = pd.to_datetime((users['timestamp_first_active'] // 1000000), format='%Y%m%d')
users['date_first_booking'] = pd.to_datetime((users['date_first_booking']))
users.drop(columns = ['timestamp_first_active'], inplace=True)

# Extract year, month and day from datetime
users['date_account_created_year'] = users['date_account_created'].dt.year
users['date_account_created_month'] = users['date_account_created'].dt.month
users['date_account_created_dayofyear'] = users['date_account_created'].dt.dayofyear
users['date_account_created_day'] = (users['date_account_created'] - users['date_account_created'].min()).dt.days

users['date_first_active_year'] = users['date_first_active'].dt.year
users['date_first_active_month'] = users['date_first_active'].dt.month
users['date_first_active_dayofyear'] = users['date_first_active'].dt.dayofyear
users['date_first_active_day'] = (users['date_first_active'] - users['date_first_active'].min()).dt.days

users['date_first_booking_year'] = users['date_first_booking'].dt.year
users['date_first_booking_month'] = users['date_first_booking'].dt.month
users['date_first_booking_dayofyear'] = users['date_first_booking'].dt.dayofyear
users['date_first_booking_day'] = (users['date_first_booking'] - users['date_first_booking'].min()).dt.days

# Create a has_age column
users['has_age'] = ~pd.isna(users['age'])
categorical_features.append('has_age')

# Create bucket for 'age' columns
labels = [str(i) + '-' + str(i+9) for i in range(15, 95, 10)]
users['age_bkt'] = pd.cut(users['age'], bins = range(15, 105, 10), labels = labels)
users['age_bkt'].replace(np.nan, 'NA', inplace = True)
# users['age_bkt'].value_counts()
categorical_features.append('age_bkt')

"""## 3. Plot

#### Useful functions
"""

def plot_catogory_distribution(data, column_name, title = None, percentage = False, rot = 0):
    if percentage == False:
        data[column_name].value_counts(dropna=False).plot(kind='bar', color = 'c', rot = 0)
    else:
        (data[column_name].value_counts(dropna=False) / data.shape[0]*100).plot(kind='bar', color = 'c', rot = rot)

    if percentage == False:
        plt.ylabel('No. of users')
    else:
        plt.ylabel('% of users')

    plt.title(title)
    plt.show()

def plot_continuous_distribution_as_bar(data, column_name, title = None, bins = None):
    sns.distplot(data[column_name].dropna(), bins = bins)
    plt.title(title)
    plt.show()

def plot_continuous_distribution_as_box(data, continuous_column, category_column = None, title = None):
    sns.boxplot(y = continuous_column , x = category_column, data = data, color = 'c')
    plt.title(title)
    plt.show()

def plot_category_stack(data, x_column, y_column, percentage = False, title = None, rot = 0):
    if percentage == False:
        ctab=pd.crosstab(data[x_column], data[y_column])
    else:
        ctab=pd.crosstab(data[x_column], data[y_column]).apply(lambda x: x/x.sum()*100, axis=1)

    ctab.plot(kind='bar',stacked=True,legend=True, rot = rot)

    if percentage == False:
        plt.ylabel('No. of users')
    else:
        plt.ylabel('% of users')
    plt.title(title)
    plt.show()

def plot_category_bar(data,level_1, level_2, title = None):
    sns.catplot(data = data, x = level_1, hue = level_2, kind = "count", height = 8, aspect = 1.5)
    plt.title(title)
    plt.show()

"""#### Useful sub-data"""

train = users[users['data'] == 'train'].drop(columns = ['data'])
test = users[users['data'] == 'test'].drop(columns = ['data'])
train['has_destination'] = (train['country_destination'] != 'NDF')
train_has_destination = train[train['country_destination'] != 'NDF']
train_has_destination['to_US'] = (train['country_destination'] == 'US')
train_has_destination_not_US = train_has_destination[train_has_destination['country_destination'] != 'US']

"""### Continuous Column

#### Age
"""

# Distribution of user's age
plot_continuous_distribution_as_bar(data = users, column_name = 'age', title = "Age Distribution of users", bins = 16)
# Finding: Most of our users have never booked.
# US is the most populor choice as the dataset is from the US users who would likely to prefer travel to nearer place within their home country

# Distribution of user's age across the destination countries
plot_continuous_distribution_as_box(data = users, continuous_column = 'age', category_column = 'country_destination', title = 'Age Distribution across the destinations')
# Finding: Almost all the countries have a similar median age. Only users tavelling to Spain and Portugal are slightly younger.
# Users of age 80 and above mostly choose US as their destination.
# The reason might be the US user data i.e. as all the users are from US, older people in US prefer not to travel outside their home country.

"""### Categorical Column

#### Destination
"""

# Distribution of user's selection of country
plot_catogory_distribution(train, 'country_destination', title = "Distribution of destination countries")
plot_catogory_distribution(train_has_destination, 'country_destination', title = "Distribution of destination countries")
# Finding: Almost all the countries have a similar median age. Only users tavelling to Spain and Portugal are slightly younger.

"""#### Gender"""

# Distribution of user's gender
plot_catogory_distribution(train, 'gender', title = "Gender Distribution of users")
plot_catogory_distribution(train_has_destination, 'gender', title = "Gender Distribution of users")
# Finding: Female and Male are around the same.
# It means that the difference between the gender of the users is not significant.
# Also, around one third of the gender information is missing from the dataset.

# Distribution of user's gender across the destination countries
plot_category_stack(data = train, x_column = 'gender', y_column = 'country_destination')
plot_category_stack(data = train_has_destination, x_column = 'gender', y_column = 'country_destination')
plot_category_stack(data = train_has_destination_not_US, x_column = 'gender', y_column = 'country_destination')
plot_category_stack(data = train, x_column = 'country_destination', y_column = 'gender', percentage = True)
plot_category_bar(data = train, level_1 = 'country_destination', level_2 = 'gender', title = None)
# The bookings made by females are slightly higher for most of the destination countries
# except for Canada, Denmark, Netherlands and other(not mentioned) countries where booking by males are slightly more than the females.

"""#### Language

#### Sign up method
"""

# Distribution of user signup method distribution
plot_catogory_distribution(train, 'signup_method', title = "Distribution of signup method", percentage = True)
plot_catogory_distribution(train_has_destination, 'signup_method', title = "Distribution of signup method")
# Two thirds of the users use the basic signup method to register themselves on Airbnb, followed by Facebook.

# Booking rate of each signup method
plot_category_stack(data = train, x_column = 'signup_method', y_column = 'has_destination', percentage = True)
# Basic sign up has higher booking rate

# Distribution of user's signup method across the destination countries
plot_category_stack(data = train, x_column = 'country_destination', y_column = 'signup_method', percentage = True)
# Basic signup method is most common among users to signup into Airbnb to book any of the destination countries.

"""#### Sign up App"""

# Distribution of user signup app distribution
plot_catogory_distribution(train, 'signup_app', title = "Signup app distribution of users")
# More than 80% of the users signup using Web, followed by iOS, Mobile Web and Android.

# Distribution of user's signup app across the destination countries
plot_category_stack(data = train, x_column = 'country_destination', y_column = 'signup_app', percentage = True)
plot_category_bar(data = train, level_1 = 'country_destination', level_2 = 'signup_app', title = None)
# users mostly use web irrespective of booking any of the destination countries.

"""#### Sign up flow"""

# Distribution of user sign up flow distribution
plot_catogory_distribution(train, 'signup_flow', title = "Distribution of sign up flow")
plot_catogory_distribution(train_has_destination, 'signup_flow', title = "Distribution of sign up flow")
# Most users came from the same website to sign up

# Booking rate of each signup flow page
plot_category_stack(data = train, x_column = 'signup_flow', y_column = 'has_destination', percentage = True)

# Distribution of user's signup app across the destination countries
plot_category_stack(data = train, x_column = 'country_destination', y_column = 'signup_flow', percentage = True)
# Dispite its least effectiveness, Direct paid marketing is still responsible for attracting most of the users to use Airbnb
# due its ability to attract many users

"""#### Affiliate Channel (which paid marketing)"""

# Distribution of user signup app distribution
plot_catogory_distribution(train, 'affiliate_channel', title = "Distribution of Affiliate channels used to attract the users")
plot_catogory_distribution(train_has_destination, 'affiliate_channel', title = "Distribution of Affiliate channels used to attract the users")
# Direct paid marketing is responsible for attracting most of the users to use Airbnb

# Booking rate of each channel
plot_category_stack(data = train, x_column = 'affiliate_channel', y_column = 'has_destination', percentage = True)
# However, it is the least effective in making users book travel experience

# Distribution of user's signup app across the destination countries
plot_category_stack(data = train, x_column = 'country_destination', y_column = 'affiliate_channel', percentage = True)
# Dispite its least effectiveness, Direct paid marketing is still responsible for attracting most of the users to use Airbnb
# due its ability to attract many users



"""#### Affiliate Provider (where the marketing)

#### First Affiliate Tracked (the first marketing the user interacted with before the signing up)

#### First Device Type
"""

# Distribution of user first device type
plot_catogory_distribution(train, 'first_device_type', title = "Distribution of first device type", percentage = True, rot = 30)
plot_catogory_distribution(train_has_destination, 'first_device_type', title = "Distribution of first device type", percentage = True, rot = 30)
# 30% of the users use Mac Desktop for fist access to Airbnb.
# More than 40% of the users who book used Mac Desktop for fist access to Airbnb.
# Also, Mac Desktop and Windows Desktop together constitute appoximately 80% of all the users who use Desktop as the first device to access Airbnb.
# This supports our earlier result that stated "80% of users use Web as a signup app to register on Airbnb".
# With the assuption that users use the same device when signing up and accessing Airbnb for first time

# Booking rate of each signup device
plot_category_stack(data = train, x_column = 'first_device_type', y_column = 'has_destination', percentage = True, rot = 30)
# Mac Desktop and Window Desktop has higher sign up rate.
# Mac Desktop and Windows Desktop have been the most popular first devices used by users to access Airbnb.
# iPhone is used more than iPad as a first device by the users to access Airbnb
# But iPad is used more than iPhone as a first device by the users who book their places in countries.

# Distribution of user's first device type across the destination countries
plot_category_stack(data = train, x_column = 'country_destination', y_column = 'first_device_type', percentage = True)
# Phones has lower booking rate compared to laptops and pads.

"""#### First Browser"""

# Distribution of user first browser
plot_catogory_distribution(train, 'first_browser', title = "Distribution of first browser", percentage = True, rot = 60)
plot_catogory_distribution(train_has_destination, 'first_browser', title = "Distribution of first browser", percentage = True, rot = 60)
plot_catogory_distribution(train_has_destination, 'first_browser', title = "Distribution of first browser", percentage = False, rot = 60)
# 25% of users use Chrome to access Airbnb, followed by Safari and Firefox.

unpopular_browsers = list((train.first_browser.value_counts()[7:]).index)

# Booking rate of each browser varies a lot
plot_category_stack(data = train[~train['first_browser'].isin(unpopular_browsers)], x_column = 'first_browser', y_column = 'has_destination', percentage = True, rot = 60)

# Distribution of user's first browser across the destination countries
plot_category_stack(data = train, x_column = 'country_destination', y_column = 'first_browser', percentage = True)
# Phones has lower booking rate compared to laptops and pads.

"""### Time Trend

#### Data First Active
"""

def plot_counts_trend(data, column, title = None):
    data[column].value_counts().plot(kind='line',linewidth=1)
    plt.ylabel("No. of Customers")
    plt.xlabel("Date")
    plt.show()

train['date_first_active'].value_counts().plot(kind='line',linewidth=1)

plot_counts_trend(data = train, column = 'date_first_active', title = None)

plot_counts_trend(data = train, column = 'date_account_created_day', title = None)

"""#### Date Account Created"""

plot_counts_trend(data = train, column = 'date_account_created', title = None)
plot_counts_trend(data = test, column = 'date_account_created', title = None)
plot_counts_trend(data = users, column = 'date_account_created', title = None)
# There was a huge rise in user registration after 2014.
# This was the time when Airbnb's business started to boom and since then it has expanded at a very high rate.



"""#### Date First Booking

## Ignore
"""

# 2. bubble plot of total search and click rate/ATCR ---------------------------
def plot_bubble_chart(df, folder_name, category):

    columns = ['CTR', 'ATCR']

    selected_categories = df.groupby([df.columns[0]])['Total Search'].sum().reset_index().sort_values('Total Search').tail(12)[df.columns[0]]
    df = df[df[df.columns[0]].isin(selected_categories)]


    for column in columns:
        fig = sns.relplot(x="Total Search", y=column, size="Total Search", hue="Total Search",
            sizes=(1000, 10000), data=df, height=8, aspect=12/8, legend = False)
        bbox_props = dict(boxstyle="round", fc="w", ec="0.5", alpha=0.6)
        for line in range(0,df.shape[0]):
             plt.text(df["Total Search"].iloc[line], df[column].iloc[line], df[df.columns[0]].iloc[line],
                bbox=bbox_props, horizontalalignment='left', size='large', color='black', fontsize = 20)
        title = column + ' vc Total Search by ' + category
        plt.xlim(0, df['Total Search'].max()*1.1)
        plt.ylim(0, df[column].max()*1.1)
        x = np.linspace(0, df['Total Search'].max()*1.1, df['Total Search'].max()*1.1)
        y = [df[column].mean()] * len(x)
        plt.plot(x, y, linewidth = 2, color = 'red')
        plt.title(title, loc = 'center', y=1.08, fontsize = 25)

        if folder_name != 'NA':
            folder_name = folder_name.replace(': ', '-').replace(':', '-').replace(' ', '_')
            check_dir(folder_name)
            image_name = ('Total_Search_vs_' + column + '-' + category + '.png').replace(': ', '-').replace(':', '-').replace(' ', '_')
            saved_path = os.path.join(folder_name, image_name)
            fig.savefig(saved_path, dpi=200, bbox_inches="tight")
            print('{}: Finished getting click rate for {}. Saved to {}'.format(datetime.datetime.now(), image_name, saved_path))
        else:
            plt.show()

        plt.close()

# plot_bubble_chart(generate_fixed_period_report(df, 'NA', 'Category_L3'), os.path.join(saved_directory, 'Categories', 'Category_L3','clothing', Category_L2), 'Category_L3')

# 3. Time series trend plotting of ['Total Search', 'Click', 'Add_to_Cart', 'CTR', 'ATCR', 'Total Search %', 'Click %', 'Add_to_Cart %']
def plot_trend_chart(df, folder_name, category, time_unit):

    rates = df.groupby([time_unit, category]).agg({'im_name': ['count'],'Click': ['sum'], 'Add_to_Cart': ['sum']}).reset_index()
    rates.columns = rates.columns.droplevel(-1)
    rates = rates.rename(columns = {'im_name': 'Total Search'})
    rates['CTR'] = rates['Click'] / rates['Total Search']
    rates['ATCR'] = rates['Add_to_Cart'] / rates['Total Search']
    rates = rates.sort_values([time_unit])

    rates_total = df.groupby([time_unit]).agg({'im_name': ['count'],'Click': ['sum'], 'Add_to_Cart': ['sum']}).reset_index()
    rates_total.columns = rates_total.columns.droplevel(-1)
    rates_total = rates_total.rename(columns = {'im_name': 'All Total Search', 'Click': 'All Click', 'Add_to_Cart': 'All Add_to_Cart'})

    rates = rates.merge(rates_total, on = time_unit, how = 'left')

    for column in ['Total Search', 'Click', 'Add_to_Cart']:
        rates[column + ' %'] = rates[column] / rates['All ' + column]


    title_add = ' (Top 10)' if len(rates[category].unique()) > 10 else ''

    dates = pd.date_range(start='1/1/2018', end='1/1/2019', freq='D')
    dates = pd.DataFrame(data = {'date': dates})
    dates['week'] = dates['date'].dt.week
    dates['day'] = dates['date'].dt.dayofyear

    dates = dates.drop_duplicates()
    dates = dates.sort_values(['week', 'date'])
    weeks = dates.drop_duplicates(subset = 'week')

    map = dict(zip(dates['day'], dates['date'])) if time_unit=='day' else dict(zip(weeks['week'], weeks['date']))

    if time_unit=='week':
        map.update(map_week_to_date)

    columns = ['Total Search', 'Total Search %', 'Click', 'Click %', 'CTR', 'Add_to_Cart', 'Add_to_Cart %',  'ATCR']

    for column in columns:

        selected_categories = rates.groupby([category])[column].sum().reset_index().sort_values(column).tail(10)[category]
        rates = rates[rates[category].isin(selected_categories)]

        fig = sns.lineplot(x=time_unit, y=column, hue=category, sizes=(1000, 10000), data=rates)
        time_unit_desc = 'Daily' if time_unit=='day' else 'Weekly'
        title = time_unit_desc + ' Trend of ' + column + ' by ' + category + title_add
        plt.title(title, loc = 'center', y=1.04, fontsize = 25)
        plt.legend(loc='upper left', fontsize = 14)

        ax = plt.gca()
        xticks = ax.get_xticks()
        ax.set_xticklabels([str(map[int(time)]).split(' ')[0] for time in xticks], fontsize = 15)

        if folder_name != 'NA':
            folder_name = folder_name.replace(': ', '-').replace(':', '-').replace(' ', '_')
            check_dir(folder_name)
            image_name = ('Trend-' + category + '-' + column + '_' + time_unit_desc+ '.png').replace(': ', '-').replace(':', '-').replace(' ', '_')
            saved_path = os.path.join(folder_name, image_name)
            fig.get_figure().savefig(saved_path, dpi=200, bbox_inches="tight")
            print('{}: Finished getting click rate for {}. Saved to {}'.format(datetime.datetime.now(), image_name, saved_path))
        else:
            plt.show()

        plt.close()

# plot_trend_chart(tag_results, os.path.join(saved_directory, 'Fashion_TagGroup', category), category, 'week')

# plot_trend_chart(tag_results, os.path.join(saved_directory, 'All'), 'All', 'week')

# for categorical_feature in categorical_features:
#     plot_catogory_distribution(data = train, column_name = categorical_feature, title = categorical_feature)

# for categorical_feature in ['gender', 'has_age']:
#     plot_category_stack(data = train, x_column = 'country_destination', y_column = categorical_feature)

# for categorical_feature in ['gender', 'has_age']:
#     plot_category_bar(data = train, level_1 = 'country_destination', level_2 = categorical_feature)

# for categorical_feature in categorical_features:
#     plot_category_stack(data = users, x_column = categorical_feature, y_column = 'data', percentage = True)

# # Uneven distribution of some columns for train and test (relevant?)
# # - There is no signup method of google and weibo in train data, which exist in test data.
